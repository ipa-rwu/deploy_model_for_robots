/*
 * generated by Xtext 2.27.0
 */
package de.fraunhofer.ipa.deployment.validation;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;

import de.fraunhofer.ipa.deployment.deployModel.BuildRequirements;
import de.fraunhofer.ipa.deployment.deployModel.CIParameters;
import de.fraunhofer.ipa.deployment.deployModel.CISetting;
import de.fraunhofer.ipa.deployment.deployModel.DeployModelPackage;
import de.fraunhofer.ipa.deployment.deployModel.GitPackage;
import de.fraunhofer.ipa.deployment.deployModel.GroupedProperties;
import de.fraunhofer.ipa.deployment.deployModel.ImageDescription;
import de.fraunhofer.ipa.deployment.utils.DeployModelUtils;
import de.fraunhofer.ipa.deployment.utils.DeployModelUtilsXtend;

import de.fraunhofer.ipa.deployment.deployModel.MonolithicImplementationDescription;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class DeployModelValidator extends AbstractDeployModelValidator {
	
	public static final String INVALID_NAME = "invalidName";
	public static final String DUPLICATES = "duplicates"; 
	public static final String MISSING_ENTITY = "missingEntity";
	public static final String NOT_DEFINE = "notDefine";
	
	DeployModelUtilsXtend utilsXtend = new DeployModelUtilsXtend();

	@Check
	// check the type of image tags
	public void checkImageTag(ImageDescription des) {
		List<String> list = EnumSet.allOf(CommonRules.ImageTagTypes.class).
				stream().
				map(e -> DeployModelUtils.camelToLowerUnderscore(e.name())).
				collect(Collectors.toList());
		for (String version : des.getImageTags().getValues()) {
			if(!list.contains(version)){  
			        error(String.format("'%s' is invalid. Image Version Types can be %s",
			        		version,
			        		Stream.of(CommonRules.ImageTagTypes.values()).map(CommonRules.ImageTagTypes::name).collect(Collectors.toList())),
					DeployModelPackage.Literals.IMAGE_DESCRIPTION__IMAGE_TAGS,
					INVALID_NAME);
			  }
		}
	}
	
	@Check
	// check the type of images
	public void checkImageType(ImageDescription des) {
		List<String> list = EnumSet.allOf(CommonRules.CreatedImageTypes.class).
				stream().
				map(e -> DeployModelUtils.camelToLowerUnderscore(e.name())).
				collect(Collectors.toList());
		for (String type : des.getTypes().getValues()) {
			if(!list.contains(type)){  
			        error(String.format("'%s' is invalid. Image Types can be %s",
			        		type,
			        		Stream.of(CommonRules.CreatedImageTypes.values()).map(CommonRules.CreatedImageTypes::name).collect(Collectors.toList())),
					DeployModelPackage.Literals.IMAGE_DESCRIPTION__TYPES,
					INVALID_NAME);
			  }
		}
	}
	
	@Check
	// check repository visibility
	public void checkVisibility(GitPackage pkg) {
		List<String> list = EnumSet.allOf(CommonRules.RepoVisibility.class).
				stream().
				map(e -> DeployModelUtils.camelToLowerUnderscore(e.name())).
				collect(Collectors.toList());
		if(!list.contains(pkg.getVisibility())){  
		        error(String.format("'%s' is invalid. Repository Visibility can be %s",
		        		pkg.getVisibility(),
		        		list),
				DeployModelPackage.Literals.GIT_PACKAGE__VISIBILITY,
				INVALID_NAME);
		}
	}
	
	private void checkDuplicates(List<String> list, EReference ref) {
		Set<String> duplicates = DeployModelUtils.findDuplicates(list);
		if(duplicates.size() > 0) {
			error(String.format("'%s' is already defined. Please remove it",
					duplicates),
					ref,
			DUPLICATES);
		}
	}
	
	@Check 
	// check repository types	
	public void checkCITypeInCISetting(CISetting setting){
		List<String> list = EnumSet.allOf(CommonRules.RepoTypes.class).
				stream().
				map(e -> DeployModelUtils.camelToLowerUnderscore(e.name())).
				collect(Collectors.toList());
		checkDuplicates(setting.getCiTypes().getValues(), DeployModelPackage.Literals.CI_SETTING__CI_TYPES);
		checkDuplicates(setting.getCiParameters().stream().
				map(e -> e.getType()).
				collect(Collectors.toList()), 
				DeployModelPackage.Literals.CI_SETTING__CI_PARAMETERS);
		for(Object repoType : setting.getCiTypes().getValues()) {
			if(!list.contains(repoType.toString())) {
				error(String.format("'%s' is invalid. %s %s can be %s",
		        		repoType.toString(),
		        		setting.getType().toString(),
		        		setting.getCiTypes().toString(),
		        		list),
				DeployModelPackage.Literals.CI_SETTING__CI_TYPES,
				INVALID_NAME);
			}
		}
	}
	
	@Check 
	// check repository types that can be defined with CIParameters	
	public void checkCITypeInCIParameters(CIParameters params){
		List<String> list = EnumSet.allOf(CommonRules.RepoTypes.class).
				stream().
				map(e -> DeployModelUtils.camelToLowerUnderscore(e.name())).
				collect(Collectors.toList());
		if(!list.contains(params.getType())) {
			error(String.format("'%s' is invalid. You can define properties for %s",
	        		params.getType(),
	        		list),
			DeployModelPackage.Literals.CI_PARAMETERS__TYPE,
			INVALID_NAME);
		}
	}
	
	@Check
	// check define docker service if define docker runner
	public void checkGitlabDockerRunnerService(CIParameters ciParams) {
		GroupedProperties tagPropertyGroup = null;
		GroupedProperties servicePropertyGroup = null;
		List<String> tagNames = new ArrayList<String>();
		List<String> serviceNames = new ArrayList<String>();
		if(ciParams.getType().equals(DeployModelUtils.camelToLowerUnderscore(CommonRules.RepoTypes.Gitlab.name()))) {
			for(GroupedProperties propertyGroup : ciParams.getParameters()) {
				
				if(propertyGroup.getType().equals(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabParameters.Tags.name()))){
					tagPropertyGroup = propertyGroup;
					}
				if(propertyGroup.getType().equals(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabParameters.Services.name())))	
					servicePropertyGroup = propertyGroup;
					}
			}

		if(tagPropertyGroup != null) {
			tagNames = tagPropertyGroup.getProperties().stream().map(e -> e.getName()).collect(Collectors.toList());
			}
		if(servicePropertyGroup != null) {
			serviceNames = servicePropertyGroup.getProperties().stream().map(e -> e.getName()).collect(Collectors.toList());
			}
		
		if(tagNames.contains(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerNoCache.name()))
				|| tagNames.contains(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerSaveCache.name()))
				){
			if(serviceNames.size()==0
					|| !serviceNames.contains(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerService.DockerService.name()))){
				error(String.format("\"%s\" is missing. You need to define \"%s\","
						+ "if you define a runner in \"%s\" to run docker in docker",
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerService.DockerService.name()),
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerService.DockerService.name()),
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabParameters.Tags.name())
						),
				DeployModelPackage.Literals.CI_PARAMETERS__PARAMETERS,
				MISSING_ENTITY);
			}
		}
		
		if(serviceNames.contains(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerService.DockerService.name()))){
			if(tagNames.size()==0 
					|| 
					(!tagNames.contains(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerNoCache.name()))
							&& !tagNames.contains(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerSaveCache.name()))
					)){
				error(String.format("\"%s\" or \"%s\" is missing. "
						+ "You need to define \"%s\" or \"%s\" in \"%s\", if you define a service \"%s\" in \"%s\" to run docker in docker",
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerNoCache.name()),
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerSaveCache.name()),
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerNoCache.name()),
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerSaveCache.name()),
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabParameters.Tags.name()),
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerService.DockerService.name()),
						DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabParameters.Services.name())
		        		),
						DeployModelPackage.Literals.CI_PARAMETERS__PARAMETERS,
						MISSING_ENTITY);
				}
			}
		if(tagNames.contains(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerNoCache.name()))
				&& tagNames.contains(DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerSaveCache.name()))
				) {
			error(String.format("You can not define \"%s\" and \"%s\" at the same time. "
					+ "You can difine one of them",
					DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerNoCache.name()),
					DeployModelUtils.camelToLowerUnderscore(CommonRules.GitlabDefaultRunnerTags.DockerRunnerSaveCache.name())
	        		),
					DeployModelPackage.Literals.CI_PARAMETERS__PARAMETERS,
					INVALID_NAME);
			
		}
	}
	
	@Check
	// check rosdistro name
	public void checkRosDistros(BuildRequirements buildReq) {
		List<String> distroList = EnumSet.allOf(CommonRules.RosDistros.class).
				stream().
				map(e -> DeployModelUtils.camelToLowerUnderscore(e.name())).
				collect(Collectors.toList());
		List<String> versionList = EnumSet.allOf(CommonRules.RosVersions.class).
				stream().
				map(e -> DeployModelUtils.camelToLowerUnderscore(e.name())).
				collect(Collectors.toList());
		System.out.println(versionList.toString());
		List<String> list = Stream.concat(distroList.stream(), versionList.stream()).toList();
		EList<String> reqRosDistros = buildReq.getReqRosDistros().getValues();
		EList<String> reqTestRosDistros = buildReq.getReqTestRosDistros().getValues();
		
		checkDuplicates(reqRosDistros, DeployModelPackage.Literals.BUILD_REQUIREMENTS__REQ_ROS_DISTROS);
		checkDuplicates(reqTestRosDistros, DeployModelPackage.Literals.BUILD_REQUIREMENTS__REQ_TEST_ROS_DISTROS);
		
		List<String> differences = new ArrayList<>(reqRosDistros);
		differences.removeAll(distroList);
		if(differences.size()>0) {
			error(String.format("\"%s\" is invalid ROS Distro. You can define ROS Distro with %s.",
					differences.toString(),
					list
	        		),
					DeployModelPackage.Literals.BUILD_REQUIREMENTS__REQ_ROS_DISTROS,
					INVALID_NAME);
		}
		differences = new ArrayList<>(reqTestRosDistros);
		differences.removeAll(list);
		if(differences.size()>0) {
			error(String.format("\"%s\" is invalid ROS Distro. You can define ROS Distro with %s.",
					differences.toString(),
					list
	        		),
					DeployModelPackage.Literals.BUILD_REQUIREMENTS__REQ_TEST_ROS_DISTROS,
					INVALID_NAME);
		}
	}
	
	@Check
	// if build require more than one ros distro, must set branchPrefix to not None
	public void checkBranchPrefix(CISetting ciSetting) {
		List<String> list = DeployModelUtils.enumToList(CommonRules.BranchPrefixTypes.class);
		list.remove(DeployModelUtils.camelToLowerUnderscore(CommonRules.BranchPrefixTypes.None.name()));
		EList<MonolithicImplementationDescription> monImpls = ciSetting.getAppliedRepos().getValues();
		for(MonolithicImplementationDescription monImpl: monImpls) {
			EList<String> reqRosDistros = monImpl.getImplementation().getBuildRequirements().getReqRosDistros().getValues();			
			if(reqRosDistros.size()>0) {
				if (ciSetting.getReqBranchPrefix().equals(DeployModelUtils.camelToLowerUnderscore(CommonRules.BranchPrefixTypes.None.name()))) {
					error(String.format("You can not define \"%s\" as \"branchPrefixType\" since you want to build for multiple ros distro. "
							+ "You can define \"branchPrefixType\" as %s.",
							ciSetting.getReqBranchPrefix(),
							list
			        		),
							DeployModelPackage.Literals.CI_SETTING__REQ_BRANCH_PREFIX,
							INVALID_NAME);
				}
			}			
		}

	}
	
}
	
